# STM32+FreeRTOS 智能手表项目 - 技术难点与架构演进文档

本文档记录了本项目在开发过程中遇到的关键技术挑战、架构设计决策以及具体的解决方案。

## 1. 项目概述
本项目基于 STM32F103C8T6 微控制器和 FreeRTOS 实时操作系统，构建了一个模块化的智能手表系统。项目集成了 OLED 显示、MPU6050 姿态解算、RTC 时钟以及多个交互式应用（恐龙游戏、秒表等）。

## 2. 遇到的棘手问题与技术攻克

### 2.1 UI 系统的上帝对象重构 (Refactoring the "God Object")

**问题描述：**
在项目初期，所有的 UI 绘制逻辑、按键处理逻辑以及应用状态管理都集中在 menu.c 一个文件中。随着功能增加（加入游戏、设置、MPU6050 显示），该文件变得极其臃肿，函数之间耦合度极高。修改一个简单的菜单项可能会意外破坏时钟显示的逻辑，代码维护成本极高。

**技术攻克：Page Controller（页面控制器）模式**
为了解决此问题，我们实施了 UI 架构的模块化重构：
1.  **抽象接口**：定义了统一的页面行为接口。每个页面（Page）必须实现 Draw()（绘制）、HandleKey()（按键处理）和 Reset()（状态重置）函数。
2.  **路由分发**：创建 UI_Manager 模块作为路由器。它维护当前的 CurrentPage 状态，并根据状态将系统事件（刷新、按键）分发给对应的页面控制器。
3.  **物理拆分**：将代码物理拆分为 Page_Clock.c（时钟）、Page_Menu.c（主菜单）、Page_Apps.c（具体应用）。
    *   *效果*：实现了高内聚低耦合，新增一个页面只需增加一个文件并在管理器注册即可，不再影响现有代码。

### 2.2 游戏逻辑与硬件驱动的解耦 (Decoupling Game Logic)

**问题描述：**
恐龙游戏模块 (dino.c) 最初是为了快速实现而编写的，它在游戏的主循环中直接包含了 Key.h 并调用 Key_GetNum() 来检测跳跃动作。
这种设计导致了两个严重问题：
1.  **破坏了事件驱动架构**：游戏绕过了主程序的事件分发机制，直接抢占硬件资源。
2.  **不可移植性**：游戏逻辑与特定的按键驱动绑定，无法轻易移植到其他平台，也无法通过其他方式（如重力感应）控制跳跃。

**技术攻克：依赖倒置与事件注入**
我们对游戏模块进行了手术：
1.  **移除依赖**：从 dino.c 中删除了所有对硬件层 (Key.h) 的引用。
2.  **接口暴露**：游戏模块仅暴露一个控制接口 oid Dino_Jump(void)。
3.  **控制反转**：在 Page_Apps.c 的 Page_Game_HandleKey 函数中监听按键事件。当检测到确认键时，由 UI 层调用 Dino_Jump()。
    *   *效果*：游戏引擎变成了纯粹的逻辑计算，不再关心输入是来自按键、触摸屏还是 AI 算法。

### 2.3 FreeRTOS 环境下的隐式声明陷阱 (Implicit Declaration Hell)

**问题描述：**
在重构过程中，我们移除了旧的 menu.h。由于原先 menu.h 为了方便，在内部包含了 LED.h, MyRTC.h, MPU6050.h 等所有外设头文件，main.c 一直依赖这种传递性包含。移除 menu.h 后，编译器在编译 main.c 时报出了大量Implicit declaration of function警告，导致链接阶段可能出错或运行时崩溃。

**技术攻克：显式依赖管理**
我们采取了更严格的头文件管理策略：
1.  **显式引入**：在 main.c 中逐一添加了缺失的头文件 (#include "LED.h", #include "MyRTC.h" 等)。
2.  **原则确立**：确立了谁使用，谁包含的原则，禁止依赖头文件的嵌套包含来获取函数声明。这极大地提高了代码的可读性和编译的稳定性。

### 2.4 Keil 工程与文件系统的同步 (IDE & Filesystem Sync)

**问题描述：**
我们使用 VS Code 进行代码编辑和重构（移动文件、创建文件夹），但 Keil MDK 的工程文件 (.uvprojx) 不会自动感知文件系统的变化。这导致在 VS Code 中写好的代码，在 Keil 中编译时提示File not found或链接错误。

**技术攻克：规范化工程更新流程**
建立了一套标准的操作流程来确保环境同步：
1.  **文件系统重构**：在 VS Code 中建立清晰的目录结构 (App/UI/Pages/)。
2.  **IDE 映射**：在 Keil 中手动创建对应的 Group，并添加新生成的 .c 文件。
3. **路径配置**：在 Keil 的 C/C++ 选项卡中，将新目录 (.\App\UI\Pages) 添加到 Include Paths 中。

### 2.5 FreeRTOS 调度器启动卡死 (Scheduler Freeze on Startup)

**问题描述：**
在系统资源极其紧张（SRAM 仅 20KB）的情况下，即使将堆栈大小优化到极限，系统在调用 `vTaskStartScheduler()` 后仍然卡死，无法进入第一个任务。调试发现问题出在调度器启动时，无法为 **Idle Task**（空闲任务）和 **Timer Task**（定时器任务）成功分配动态内存。

**技术攻克：静态内存分配 (Static Memory Allocation)**
为了彻底解决启动时的内存分配风险，我们采取了静态分配策略：
1.  **配置变更**：在 `FreeRTOSConfig.h` 中启用 `configSUPPORT_STATIC_ALLOCATION = 1`。
2.  **回调实现**：实现了 `vApplicationGetIdleTaskMemory()` 和 `vApplicationGetTimerTaskMemory()` 接口。
3.  **机制原理**：手动定义全局静态变量作为任务控制块 (TCB) 和栈空间，不再依赖堆 (Heap) 分配器。
    *   *效果*：确保了无论堆内存多么碎片化或紧缺，系统核心任务（Idle/Timer）所需的内存始终是预留且可用的，成功解决了启动卡死问题。

## 3. 架构现状
经过上述改进，目前的系统架构如下：

*   **硬件抽象层 (HAL/Drivers)**: Key, OLED, MPU6050, LED (负责底层寄存器操作)
*   **操作系统层 (OS)**: FreeRTOS (负责任务调度)
*   **应用框架层 (Framework)**: UI_Manager (负责页面路由), App_Tasks (负责业务流程)
*   **业务逻辑层 (Business Logic)**: Page_Clock, Page_Apps, dino (纯业务逻辑)

---
*文档生成日期: 2025年11月27日*
